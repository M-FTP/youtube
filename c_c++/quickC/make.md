# การใช้ make ฉบับย่อ

ถ้าเราเขียนโปรแกรมขนาดใหญ่ๆ มีโค้ดมากมายและ 
ต้องมีการแก้ไขอยู่เสมอๆ จะมาคอยจำว่าตรงนี้แก้ไปแล้ว 
ส่วนไหนที่เกี่ยวข้องกับตรงที่เราแก้ไข และไฟล์ไหนเป็นต้องทำการคอมไพล์ซ้ำ

ก็ลำบากอยู่เหมือนกัน ดังนั้นโปรแกรม make จะเป็นพระเอกในงานนี้ 
โปรแกรม make นี้จะทำหน้าที่ดูความสัมพันธ์ระหว่างไฟล์ที่อยู่ในโปรเจ็กของเรา 
บางทีก็เรียกว่าเป็น โปรเจ็ก manager หน้าที่ของเราก็คือสร้างไฟล์ที่ชื่อ 
Makefile ซึ่งในไฟล์นั้นเราจะเขียนว่า ไฟล์ไหน
มีความสัมพันธ์กันบ้าง แล้วจะต้องจัดการกับมันอย่างไร ซึ่งการเขียน 
Makefile ก็ถือว่าเป็นภาษาอีกภาษาหนึ่งเหมือนกัน ถึงแม้ภาษาจะไม่สมบูรณ์
ในตัวมันเองก็ตาม มาดูกันเลย

สมมุติว่าโปรเจ็กของเรามีจะสร้างโปรแกรมสองโปรแกรม 
แล้วการใช้ฟังก์ชันร่วมกัน เราจะมีโค้ดดังนี้

pro1.c - โปรแกรมแรก

pro2.c - โปรแกรมที่สอง

common.c - ฟังก์ชันที่ใช้ร่วมกัน

เวลาเราทำการคอมไพล์ก็ทำราวๆนี้
``` sh
gcc -c pro1.c 
gcc -c pro2.c
gcc -c common.c 
```
จะได้ไฟล์ pro1.o., pro2.o, common.o ออกมา เวลาจะ
คอมไพล์เป็นโปรแกรมก็ทำดังนี้
``` sh
gcc pro1.o common.o -o pro1
gcc pro2.o common.o -o pro2
```
จะได้โปรแกรมชื่อ pro1 และ pro2 ออกมา 
เงื่อนไขของการคอมไพล์โปรแกรมซ้ำถ้ามีการแก้ไขโค้ดก็คือ 
ถ้ามีการแก้ไข pro.c ก็ต้องทำดังนี้
```sh
gcc -c pro1.c 
gcc pro1.o common.o -o pro1
```
ถ้ามีการแก้ไข pro2.c ก็ต้องทำคล้ายกันดังนี้
```
gcc -c pro2.c 
gcc pro2.o common.o -o pro2
```
ถ้ามีการแก้ไขไฟล์ common.c ก็ต้องทำดังนี้
```
gcc -c common.c 
gcc pro1.o common.o -o pro1
gcc pro2.o common.o -o pro2
```
เวลาทำงานจริงๆก็ทำลองดูดังนี้ครับ ผมขอใช้คำสั่ง cat เพื่อแสดงว่า 
โปรแกรมมีโค้ดอย่างไรก็แล้วกัน 
```
$ cat pro1.c
main()
{
        printf("This is program 1\n");
        print_hello();
}
$ cat pro2.c
main()
{
        printf("This is program 2\n");
        print_hello();
}
$ cat common.c
print_hello()
{
        printf("hello from common\n");
}
$ ls
common.c  pro1.c  pro2.c
$ gcc -c common.c
$ gcc -c pro1.c
$ gcc -c pro2.c
$ ls
common.c  common.o  pro1.c  pro1.o  pro2.c  pro2.o
$ gcc pro1.o common.o -o pro1
$ gcc pro2.o common.o -o pro2
$ ./pro1
This is program 1
hello from common
$ ./pro2
This is program 2
hello from common
$
```
ลองคิดดูถ้าเรามีไฟล์อยู่หลายๆ ไฟล์คงปวดหัวหน้าดูเลยแฮะ 
ดังนั้น Makefile จะมาช่วยแบ่งเบาด้านนี้ โดยเราจะเขียนดังนี้
``` make
all : pro1 pro2

clean :
        rm -f *.o pro1 pro2

common.o : common.c
	gcc -c common.c

pro1.o : pro1.c
	gcc -c pro1.c

pro2.o : pro2.c
	gcc -c pro2.c

pro1 : pro1.o common.o
	gcc pro1.o common.o -o pro1

pro2 : pro2.o common.o
	gcc pro1.o common.o -o pro2
```

ให้เซฟเป็นไฟล์ชื่อ Makefile เวลาใช้งาน 
ถ้าต้องการสร้างโปรแกรมแรกก็แค่พิมพ์ 
    $ make pro1 

หรือถ้าต้องการสร้างโปรแกรมทั้งสองอันก็พิมพ์
    $ make all

หรือสร้างแค่ออปเจ็กไฟล์ที่ต้องการ ก็
    $ make common.o

อธิบายหลักการเขียนกฎทีีใช้ใน make ได้ดังนี้ ให้สังเกตุเครื่องหมาย
โคลอน ":" ฝั่งซ้ายจะเป็นเป้าหมายที่ต้องการ ฝั่งขวาจะเป็นวัตถุดิบที่จะใช้ 
บรรทัดข้างใต้เครื่องหมายโคลอน จะเป็นวิธีการสร้างเป้าหมาย 
ลองดูสองบรรทัดข้างล่างนี้
``` make
pro1 : pro1.o common.o
	gcc pro1.o common.o -o pro1
```
อธิบายได้ว่าถ้าต้องการสร้าง pro1 จะต้องมี pro1.o และ common.o 
เสียก่อน ถ้ามีครบแล้วก็ให้ทำตามบรรทัดที่สองก็จะได้ pro1 ออกมา 
ถ้ายังไม่มีวัตถุดิบอันไหนก็จะไปดูกฎอันอื่นๆ ก่อนว่ามีอันไหนที่สามารถ
ผลิดสิ่งที่ต้องการหาออกมาได้บ้าง อย่างถ้าต้องการ pro1.o 
มันก็จะไปดูสองบรรทัดนี้

``` make
pro1.o : pro1.c
	gcc -c pro1.c
```

การเขียน Makefile นั้นกฎ สำหรับการสร้างวัตถุดิบ ไม่จำเป็นต้องเรียงลำดับกัน 
ใส่ไว้ตรงไหนก็ได้ make มันจะทำการหาเอาเอง ในลักษณะของการ recursive 
เพื่อหาความสัมพันธ์ สำหรับคนที่เขียนภาษา Prolog ได้จะเห็นว่า
หลักการมันคล้ายๆกัน ถ้าทำการค้นหาจนทั่วแล้ว แต่ไม่สามารถสร้างเป้าหมาย
ที่ต้องการได้มันก็จะแสดง error ออกมา จะเห็นได้ว่าตรงเป้าหมาย all กับ clean 
จะพิเศษหน่อยซึ่งทั้งสองอันจะไม่มีการสร้างไฟล์ชื่อ all กับ  clean ออกมาจริงๆ 
เป็นแค่เอาไว้เป็นตัวแทนเฉยๆ ตรงเป้าหมาย all จะไม่มีวิธีการสร้างตัวมันเอง 
แต่มันจะบอกว่ามันต้องการ pro1 และ pro2 ซึ่ง make จะไปหาวิธีการสร้างเอาเอง 
ส่วน clean ไม่ต้องการอะไรเลยเพียงแต่มันต้องการรันคำสั่ง rm เพื่อจะลบไฟล์ทิ้ง 
ที่ใช้ -f เพื่อไม่ให้มันแสดง error ถ้าลบไฟล์ที่ต้องการไม่ได้ ตรงนี้ระวังหน่อย 
อย่าไปเผลอลบโค้ดโปรแกรมของเราเข้าหละ

เขียน Makefile แบบข้างต้นดูมันทื่อๆ ยังไงก็ไม่รู้ 
ไม่สมกับโปรแกรมเมอร์เลย เราสามารถเขียนได้อีกแบบดังนี้

``` make
CC = /usr/bin/gcc
OBJECT = pro1.o pro2.o common.o
PROGRAM = pro1 pro2

all: $(PROGRAM)

clean:
	rm -f *.o $(PROGRAM)

$(OBJECT) : %.o: %.c
	$(CC) -c $< -o $@

$(PROGRAM): %: %.o common.o
	$(CC) $+ -o $@     
```
ในตัวอย่างนี้จะเริ่มเห็นวิธีการใช้ตัวแปรแบบต่างๆ และการกำหนดกฎ 
ในการสร้างผลผลิด จากวัตถุดิบที่เรามีโดยใช้ pattern matching
การกำหนดตัวแปรของ make ก็ทำคล้ายๆกับ ตัวแปรของ Shell Script 
เวลาที่ต้องการตีความตัวแปรนั้นออกมา ก็ให้ ขึ้นต้นด้วยเครื่องหมาย $ 
แล้วชื่อตัวแปรจะอยู่ในวงเล็บ ถ้าไม่ใช้วงเล็บก็จะถือว่าตัวแปรนั้นมีความยาว
หนึ่งตัวอักษร Gnu Make จะมีตัวแปรประเถทหนึ่งชื่อ automatic variable 
เราเอาไปใช้ได้เลยโดยที่ไม่ต้องประกาศค่าก่อน ในตัวอย่างจะใช้ตัวแปรเหล่านี้

$< ใช้เก็บชื่อของวัตถุดิบ

$@ ใช้เก็บชื่อของผลผลิด

$+ ใช้เก็บ list รายชื่อของวัตถุดิบที่ต้องใช้

การใช้งาน pattern matching ก็ทำงได้ดังนี้สังเกตุตัวแปร

OBJECT = pro1.o pro2.o common.o

ตรงเครื่องหมาย "%" จะเป็นส่วนใดส่วนหนึ่งของ string 
ที่ต้องการทำการ match จากบรรทัดนี้

$(OBJECT) : %.o: %.c

ในตัวแปร OBJECT จะมีชื่อไฟล์ที่มีนามสกุลลงท้ายด้วยตัวอักษร "o" 
ดังนั้นถ้ากล่าวถึง pro1.o ก็จะถูกตีความเป็นชื่อ pro.c ซึ่งจะนำไปเป็นชื่อของ 
"วัตถุดิบ" ลองมาดูความหมายกัน
```
CC = /usr/bin/gcc
OBJECT = pro1.o pro2.o common.o
PROGRAM = pro1 pro2
```
สามบรรทัดข้างบนนี้ก็ไม่มีอะไรมากแค่ประกาศค่าของตัวแปรขึ้นมา
```
all: $(PROGRAM)
```
ผลผลิดทั้งหมดที่ตัองการก็คือ ไฟล์ที่อยู่ในตัวแปร PROGRAM
```
clean:
	rm -f *.o $(PROGRAM)
```
ทำความสะอาดโปรแกรมของเรา ลบไฟล์ ที่ลงท้ายด้วย "o" กับ 
โปรแกรมที่คอมไพล์แล้ว
```
$(OBJECT) : %.o: %.c
	$(CC) -c $< -o $@
```
กำหนดกฎการสร้างออปเจ็กไฟล์ โดยยึดกฎที่ว่าออปเจ็กไฟล์(*.o) 
เกิดจากไฟล์ที่ลงท้ายด้วย .c แล้วมีชื่อเหมือนกัน ส่วนวิธีสร้างที่อยู่
ในบรรทัดที่สอง สมมุติเราพิมพ์คำว่า
```
$ make pro1.o
```
วิธีการสร้างจะถูกแปรได้ว่า 
```
/usr/bin/gcc -c pro1.c -o pro1.o 
```
``` make
$(PROGRAM): %: %.o common.o
	$(CC) $+ -o $@     
```
กำหนดกฎการสร้างโปรแกรม โดยที่ต้องวัตถุดิบเป็น ออปเจ็กไฟล์
ที่ชื่อเหมือนโปรแกรมและลงท้ายด้วย .o กับไฟล์ common.o 
วิธีการสร้างในบรรทัดทีสองอธิบายได้ว่าให้คอมไพล์ด้วย gcc โดยอาศัย 
วัตถุดิบข้างต้น เพื่อสร้างโปรแกรม ที่มีชื่อเหมือนกับ pattern ที่พบ 

ถ้าเกิดไม่ค่อยเข้าใจตามที่อธิบายให้ลองพิมพ์คำว่า make ตามด้วยชื่อไฟล์
ที่ต้องการสร้าง(ออปเจ็กไฟล์ หรือโปรแกรม) แล้วลองดูว่า make ทำอะไรบ้าง

to be continue...

