## เขียนโปรแกรมด้วย gcc ฉบับย่อ

ในหน้านี้จะเป็นการสอนการเขียนโปรแกรมด้วยภาษา C 
เบื้องต้นบน Linux/Windows โดยจะสรุปเอาดื้อๆว่าผู้อ่าน
- ติดตั้ง gcc เรียบร้อยแล้ว 
- รู้จักวิธีการใช้ text editor มาบ้างแล้ว
- มีประสบการในการใช้ Linux/Windows แบบ command line มาพอสมควร

ผมไม่ขออธิบายตรงนี้ว่า linker (ld) คืออะไรขอใช้ gcc เพื่อการ link โปรแกรม 
เพื่อไม่ให้เสียเวลา เริ่มแรกด้วยการเขียนโปรแกรม เลยก็แล้วกัน 
ลองเขียนโปรแกรมใส่ยอดฮิต "Hello World" ให้ลองเขียนตามตัวอย่าง
``` c
main()
{
	printf("Hello World\n");
}
```
ฟังก์ชัน printf() ใช้สำหรับพิมพ์ข้อความออกทางหน้าจอ เครื่องหมาย \n 
ก็เป็นการขึ้นบรรทัดใหม่ รายละเอียดของการใช้ฟังก์ชันต่างๆ ก็ให้ลองไปอ่าน 
man ก็แล้วกัน เวลาคอมไพล์ ก็ให้พิมพ์ดังนี้ (สมมุติว่าไฟล์ชื่อ hello.c)
``` sh
$ gcc hello.c
```
ถ้าเขียนโปรแกรมไม่ผิดอะไร หลังจากที่คอมไพล์แล้วจะได้ ไฟล์ a.out 
ออกมา เวลารันโปรแกรมก็จะได้ข้อความ
``` sh
$ ./a.out
Hello World
```
ออกมา ถ้าไม่ชอบชื่อ a.out ตอนคอมไพล์ก็ให้พิมพ์
``` sh
$ gcc hello.c -o hello
```
ก็จะได้ไพล์ชื่อ hello ออกมา

Library คือกลุ่มของฟังก์ชันที่คาดว่าจะใช้บ่อย 
แล้วเป็นประโยชน์กับงานที่เราต้องการซึ่งมันจะถูกคอมไพล์เรียบร้อยแล้ว 
รอให้เราทำการ link เข้ากับโปรแกรมที่เราเขียนเท่านั้นเอง 
ปรกติถ้าเราใช้ฟังก์ชันที่ค่อนข้างมาตรฐานคอมไพล์เลอร์ จะทำการ link 
เอา library ของฟังก์ชันที่เราเรียกใช้ให้โปรแกรมของเราโดยอัตโนมัติ 
แต่ถ้าเราสร้าง library เอง หรือใช้อันที่ไม่ใช้แบบมาตรฐาน 
เราจำเป็นต้องบอกคอมไพล์เลอร์ด้วยว่าใช้ library อันไหน ให้ลองสร้าง 
myprogram.c ดังนี้
``` c
#include <math.h>
main()
{
	printf("%f \n",pow(2,10));
} 
```

หลังจากนั้นทำการคอมไพล์
``` sh
$ gcc myprogram.c
/tmp/ccY0rQ4p.o: In function `main':
/tmp/ccY0rQ4p.o(.text+0x12): undefined reference to `pow'
collect2: ld returned 1 exit status 
```
เพราะว่า gcc ไม่สามารถหาฟังก์ชัน pow() เพื่อทำการ link ได้ 
(ความจริง ld หาฟังก์ชันไม่เจอต่างหาก เพราะ gcc แอบไปเรียก ld ลับๆ) 
ที่ถูกต้องต้องพิมพ์ ดังนี้
``` sh
$ gcc myprogram.c -lm
```
มันจะไป link กับ math library ให้ลองพิมพ์
``` sh
$ ls -la /lib/libm*
-rwxr-xr-x   1 root     root       540120 Sep 20  1999 /lib/libm-2.1.2.so
lrwxrwxrwx   1 root     root           13 Oct 15 20:20 /lib/libm.so.6 -> libm-2.1.2.so
```
ออปชัน -l แล้วแปะท้ายด้วยชื่อฟังก์ชัน(ไม่รวมคำว่า lib) 
แล้วไม่ต้องสนนามสกุล library เดียวกันจะมีให้เลือกใช้ได้ว่าจะเป็นแบบ 
dynamic, static, debug ฯลฯ ขึ้นกับว่าตอนคอมไพล์ใช้ออปชันแบบไหน 
ยกตัวอย่างบน HPUX ไฟล์ libm.a จะเป็น static library ส่วน libm.sl 
จะเป็น dynamic link library

ถ้าโปรแกรมมันใหญ่ ก็ต้องแยกแต่ละฟังก์ชันเป็นหลายๆไฟล์ย่อยๆ 
ลองเขียนดังนี้

สร้างไพล์ mymain.c
``` c
myhell();
main()
{
	myhello();
}
```
สร้างไฟล์ myhello.c
```c
myhello()
{
	printf("Hello from oom\n");
}
```
เวลาคอมไพล์
``` sh
gcc mymain.c myhello.c
```
จะได้ไฟล์ a.out ออกมาถ้าโปรแกรมใหญ่ๆมาก มีโค้ดเยอะแยะ ถ้าแก้ไขไพล์เดียว 
แล้วไม่อยากเสียเวลาคอมไพล์ไพล์อื่นๆ ที่ไม่ถูกแก้ไขส่วนใหญ่จะใช้การ
คอมไพล์เป็นส่วนๆ ส่วนไหนถูกแก้ไขก็คอมไพล์ซ้ำ ให้ลองใช้โปรแกรมเดิม
ข้างต้นแต่คอมไพล์ดังนี้
``` sh
gcc mymain.c -c
gcc myhello.c -c
```
จะได้ไฟล์ mymain.o และ myhello.o ออกมา ไฟล์นี้เรียกว่าออปเจ็กไฟล์
ยังใช้งานไม่ได้ ต้องทำการ link เสียก่อนสมมุติว่าต่อมาเราแก้ไข myhello.c 
ดังนั้นเราก็ต้องพิมพ์
``` sh
gcc myhello.c -c
```
เพื่อนสร้าง myhello.o ขึ้นมาใหม่เท่านั้นเองโดยไม่ต้องคอมไพล์  mymain.c 
เมื่อทุกอย่างเรียบร้อยแล้ว และเราต้องการสร้างโปรแกรมที่พร้อมใช้งาน 
โดยให้โปรแกรมของเราชื่อ myprogram ก็เพียง พิมพ์
``` sh  
gcc mymain.o myhello.o -c myprogram
```

to be continue ...
